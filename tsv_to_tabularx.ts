import fs from 'fs';
import os from 'os';
import path from 'path';
import { spawnSync } from 'child_process';

const PROJECT_ROOT = path.resolve(__dirname, '..');
const OUTPUT_DIR = path.join(PROJECT_ROOT, 'misc', 'tables');

const LATEX_HEADER = 
  '\\renewcommand{\\arraystretch}{1.2}\n' +
  '\\setlength{\\tabcolsep}{6pt}\n';

const HEADER_ROW_GRAY = '0.95';

function latexEscape(s: string): string {
  if (s == null) return '';
  const replacements: Record<string, string> = {
    '\\': '\\textbackslash{}',
    '&': '\\&',
    '%': '\\%',
    '$': '\\$',
    '#': '\\#',
    '_': '\\_',
    '{': '\\{',
    '}': '\\}',
    '~': '\\textasciitilde{}',
    '^': '\\textasciicircum{}',
  };
  let out = '';
  for (const ch of s) out += replacements[ch] ?? ch;
  return out;
}

function makecellIfNeeded(text: string, align: 'l' | 'c' | 'r' = 'l'): string {
  if (!text) return '';
  if (text.includes('\n')) {
    const parts = text.split('\n').map(p => latexEscape(p.trim()));
    return `\\makecell[${align}]{` + parts.join(' \\ ') + '}';
  }
  return latexEscape(text);
}

function buildTabularxSpec(ncols: number): string {
  return '|' + Array.from({ length: ncols }, () => 'X').join('|') + '|';
}

function sanitizeLabel(s: string): string {
  return s.split('').map(ch => /[a-z0-9]/i.test(ch) ? ch.toLowerCase() : '-').join('').replace(/-+/g, '-').replace(/^-|-$/g, '');
}

function parseTSV(input: string): string[][] {
  const rows = input.replace(/\r\n?/g, '\n').split('\n').filter(line => line.length > 0);
  return rows.map(line => line.split('\t'));
}

function renderTSVToTex(data: string[][], caption: string | null, labelBase: string, headerColumn: boolean): string {
  const ncols = Math.max(0, ...data.map(r => r.length));
  const lines: string[] = [];
  lines.push('% Auto-generated by tsv_to_tabularx.ts');
  lines.push(LATEX_HEADER.trim());
  lines.push('\\begin{table}[htbp!]');
  lines.push('\\centering');
  if (caption) {
    lines.push(`\\caption{${latexEscape(caption)}}`);
    lines.push(`\\label{tbl:${sanitizeLabel(labelBase)}}`);
  }
  lines.push(`\\begin{tabularx}{\\linewidth}{${buildTabularxSpec(ncols)}}`);
  lines.push('\\hline');
  if (data.length > 0) lines.push(`\\rowcolor[gray]{${HEADER_ROW_GRAY}}`);

  const renderRow = (row: string[], isHeader: boolean): string => {
    const cells = row.map((raw, idx) => {
      let content = makecellIfNeeded(raw ?? '', 'l');
      if (isHeader || (headerColumn && idx === 0)) content = `\\textbf{${content}}`;
      if (headerColumn && !isHeader && idx === 0) content = `\\cellcolor[gray]{${HEADER_ROW_GRAY}}` + content;
      return content;
    });
    return cells.join(' & ') + ' \\';
  };

  if (data.length > 0) {
    lines.push(renderRow(data[0], true));
    lines.push('\\hline');
  }
  for (let i = 1; i < data.length; i++) {
    const row = data[i];
    if (row.every(cell => !cell || cell.trim() === '')) continue; // skip empty
    lines.push(renderRow(row, false));
    lines.push('\\hline');
  }

  lines.push('\\end{tabularx}');
  lines.push('\\end{table}');
  return lines.join('\n') + '\n';
}

function openEditorAndGetText(template: string): string | null {
  const tmp = path.join(os.tmpdir(), `tsv-input-${Date.now()}.txt`);
  fs.writeFileSync(tmp, template, 'utf8');
  const whichCode = spawnSync('which', ['code'], { encoding: 'utf8' });
  const hasCode = whichCode.status === 0 && whichCode.stdout.trim().length > 0;
  let res;
  if (hasCode) {
    res = spawnSync('code', ['-w', tmp], { stdio: 'inherit' });
  } else {
    // macOS fallback: open default text editor and wait until it closes
    res = spawnSync('open', ['-W', '-t', tmp], { stdio: 'inherit' });
  }
  if (res.status !== 0) {
    console.error('Failed to open editor. You can edit the temp file manually:', tmp);
    console.error('Press Enter when done editing.');
    spawnSync('read', [], { shell: true, stdio: 'inherit' });
  }
  try {
    const text = fs.readFileSync(tmp, 'utf8');
    fs.unlinkSync(tmp);
    return text;
  } catch (e) {
    return null;
  }
}

function buildEditorTemplate(defaults: { caption?: string | null; label?: string | null; out?: string | null }): string {
  const caption = defaults.caption ?? 'My Table';
  const label = defaults.label ?? 'my-table';
  const out = defaults.out ?? `misc/tables/${sanitizeLabel(label)}.tex`;
  return [
    '# TSV â†’ LaTeX tabularx input',
    '# Fill the fields below, then paste TSV after the --- line.',
    `Caption: ${caption}`,
    `Label: ${label}`,
    `Out: ${out}`,
    '---',
    '# Example: header\tcol2\tcol3',
    '# Paste your TSV rows below this line:',
    '',
  ].join('\n');
}

function parseEditorContent(content: string): { caption: string | null; label: string; out: string; tsv: string } {
  const lines = content.replace(/\r\n?/g, '\n').split('\n');
  let caption: string | null = null;
  let label = 'tsv-table';
  let out = `misc/tables/${sanitizeLabel(label)}.tex`;
  const bodyLines: string[] = [];
  let inBody = false;
  for (const raw of lines) {
    const line = raw.trimEnd();
    if (inBody) {
      // Skip template comments in the body
      if (line.startsWith('#')) continue;
      bodyLines.push(line);
      continue;
    }
    if (line === '---') { inBody = true; continue; }
    if (line.startsWith('#')) continue;
    const m = line.match(/^(Caption|Label|Out):\s*(.*)$/);
    if (m) {
      const key = m[1];
      const val = m[2].trim();
      if (key === 'Caption') caption = val || null;
      else if (key === 'Label') label = val || label;
      else if (key === 'Out') out = val || out;
    }
  }
  if (!out) out = `misc/tables/${sanitizeLabel(label)}.tex`;
  return { caption, label, out, tsv: bodyLines.join('\n') };
}

function main() {
  const args = process.argv.slice(2);
  const inputIdx = args.indexOf('--input-file');
  const inputFile = inputIdx >= 0 ? args[inputIdx + 1] : null;
  const outIdx = args.indexOf('--out');
  const outPath = outIdx >= 0 ? args[outIdx + 1] : null;
  const captionIdx = args.indexOf('--caption');
  let caption: string | null = captionIdx >= 0 ? args[captionIdx + 1] : null;
  const labelIdx = args.indexOf('--label');
  let label: string = labelIdx >= 0 ? args[labelIdx + 1] : 'tsv-table';
  const editor = args.includes('--open-editor');
  const headerColumn = args.includes('--header-col');

  if (editor) {
    const tmpl = buildEditorTemplate({ caption, label, out: outPath ?? null });
    const edited = openEditorAndGetText(tmpl);
    if (!edited) { console.error('No input captured.'); process.exit(1); }
    const parsed = parseEditorContent(edited);
    caption = parsed.caption;
    label = parsed.label || label;
    const tsv = parsed.tsv;
    const data = parseTSV(tsv);
    if (data.length === 0) { console.error('No rows parsed from TSV.'); process.exit(1); }
    const tex = renderTSVToTex(data, caption, label, headerColumn);
    const out = outPath ?? parsed.out ?? path.join(OUTPUT_DIR, `${sanitizeLabel(label)}.tex`);
    fs.mkdirSync(path.dirname(out), { recursive: true });
    fs.writeFileSync(out, tex, 'utf8');
    console.log(`Wrote ${path.relative(PROJECT_ROOT, out)}`);
    return;
  }

  // file mode
  let inputText: string | null = null;
  if (inputFile) {
    try { inputText = fs.readFileSync(path.resolve(inputFile), 'utf8'); } catch (e) { console.error('Failed to read input file:', inputFile); process.exit(1); }
  } else {
    console.error('Provide --open-editor or --input-file <path>');
    process.exit(1);
  }
  if (!inputText) { console.error('No input captured.'); process.exit(1); }
  const data = parseTSV(inputText);
  if (data.length === 0) { console.error('No rows parsed from TSV.'); process.exit(1); }
  const tex = renderTSVToTex(data, caption, label, headerColumn);
  const out = outPath ?? path.join(OUTPUT_DIR, `${sanitizeLabel(label)}.tex`);
  fs.mkdirSync(path.dirname(out), { recursive: true });
  fs.writeFileSync(out, tex, 'utf8');
  console.log(`Wrote ${path.relative(PROJECT_ROOT, out)}`);
}

main();
